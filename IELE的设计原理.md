IELE作为一个统一的，更低层次的平台，用于翻译和执行高级语言的智能合约。

IELE设计来源于K框架中定义数十种语言经验，基于K框架定义了两个虚拟机：

-  KEVM，即EVM语义；
-  KLLVM，即LLVM语义。

EVM基于栈，而IELE类似LLVM基于寄存器。类似于LLVM也直接支持函数  、寄存器数量无限制、整形值无限制。

在gas计算方面的精细处理是是其设计的关键。

#  1.设计背景

##  1.统一用于翻译、执行高级语言编写的智能合约底层平台，合约也可通过ABI交互

ABI是IELE的核心元素，而不仅仅是基于它的一个协议。由于LLVM的成功，长远看无限制的寄存器集整形值，使得高级语言的编译更佳高效。

而许多LLVM优化确实在持续进行中。因此，LELE尽可能遵循LLVM的设计原则。团队中也有来自伊尼诺伊大学(LLVM的起源地)的LLVM专家。

##  2.为所有语言提供统一的gas模型

IELE的gas计算总体设计理念是 “无约束，但需为消费付费”。如IELE程序使用越多的寄存器，就会消费越多的gas。

或者运行时计算数值越大、使用内存越多，也会消费越多的gas。等等。。。

##  3.更容易编写安全的智能合约

包含编写智能合约需遵守的规范、及更容易开发自动化技术。该技术以数学方式验证／证明智能合约符合规范。

例如将一个计算数字压栈，将其作为地址跳转。这样验证困难、且由于智能合约模式导致安全性减弱。

LELE类似LLVM，命名了label，跳转语句智能跳转到那些label。

避免使用栈边界、不用担心栈溢出、算术溢出，这是的智能合约的规范与验证更加容易。

##  4.形式化语义及解释器

像KEVM一样，使用K框架定义、验证集评估EVM的形式化语义。IELE的设计也是使用K框架的形式化形式。

为K提供一个快速执行后端(基于LLVM)目前处于开发中，预计解释器自动获得从IELE语义，将足够充分作为IELE的补充实现。

#  2.IELE相对于EVM设计的差异

##  1.寄存器

不同于EVM，IELE是基于寄存器的字节码语言。因此有下列不同之处：

-  字节码的每条指令均需包含寄存器操作数，表示参数及指令结果。

-  寄存器数量使用无限制。与LLVM的虚拟寄存器类似，用户可自定义寄存器名。合约使用寄存器越多，消耗的gas越多。

-  由于栈不复存在，虚拟机不会由于栈溢出而抛异常。

-  由于栈不复存在，不再需要POP／PUSH／DUP／SWAP指令。他们可以被load/move替代。即load一个常数到寄存器、值在寄存器间的move。

-  寄存器仅在函数作用域可见。(即一个函数一个栈帧)

-  寄存器的生命周期，等于函数调用包含的寄存器生命周期。

##  2.程序结构

一个IELE程序由一系列合约构成，合约链表后面的合约可创建账户，这些账户可在之前合约部署。不同于EVM的合约是一个

指令序列，IELE合约是由一个一个指定合约名字的头部、紧接着一个或多个函数定义、可选的一个或多个外部合约声明构成。

-  外部合约声明仅简单声明另一个合约名。定义的合约只能创建部署合约代码副本的账户。这些合约外部声明，或者现有

账户代码的副本。每个外部声明合约应该在同一个文件定义，且在外部声明的合约之前。

-  函数定义包含函数签名、函数体及函数是否public属性。一个函数签名包含函数名(前缀符号@)

及形参(即仅在函数体内可见的寄存器)。

-  一个public函数可被其他合约调用，而非public函数则只能被同一个合约中的其他函数调用。

-  应该为每一个合约定义一个特殊的名为@init的私有函数，则合约创建账户时使用。若没定义，合约不正常。

-  从未部署过代码的账户包含一个隐式public函数@deposit，它不接受任何参数、无返回值、不执行任何操作。

该函数是为了在无合约部署其上时账户仍然能接收到付款，这类似于EVM中无代码调用账户。注意，合约可通过拒绝

声明@deposit函数来禁止付款，并在通过余额转账任何入口处显示抛异常。合约还可以通过自定义deposit函数

来自定义执行代码。

-  全局定义定义了一个全局的名称及常量值(无穷大的符号整数)。全局值在合约内所有函数可访问，且值不可修改。

-  如果包含相同名字的多个函数活着全局变量，则合约错误。

##  3.静态跳转

IELE无动态跳转指令，它被带一个label作为参数的跳转指令替代，并通过call/return的机制使得从函数调用的

callee返回到caller。

-  函数代码包含label名。任何指令都可以用一个label作为前缀，这即支持该条指令可作为跳转目标。

-  br指令由两个变种。可用作无条件跳转，函数体内label名作为单一参数。也可以在条件值非零时带一个寄存器

参数作为条件跳转的条件值。因此，所有跳转地址均静态已知。

-  如果同一个函数中含有多个label，其名字相同，则合约错误。

-  如果br指令的label参数，在函数内包含本指令作为label没找到，则合约错误。这不同于EVM，如果JUMP／JUMPi

的参数不是JUMPDEST指令的PC，则会抛异常。

##  4.函数调用／返回

##  5.任意精度

##  6.本地执行内存(Memory)

不同于EVM使用2^256的字节数组作为本地执行内存，IELE本地执行内存是一个2^256的任意长度字节缓冲区。

-  无限大的符号整数优先用MSB存储(偏移为0)。load/store指令有两种变体：

-  种是访问完整数据单元作为无限大的符号整数，一种是访问数据单元的部分字节。

-  与EVM类似的是，当当前合约执行返回时，本地执行内存会被清理。

##  7.账户存储(Storage)

不同于EVM的是，账户存储是一个2^256单元的256 bit数组，IELE账户存储是一个无限大的符号整数的数组。

类似于EVM的是，LELE的账户存储在合约调用及返回均有效，其仅在账户被清理时才会被清除。

##  8.指令及预编译合约

##  9.合约创建

##  10.gas模型

由于上述诸多改变，有必要建立一个精确的IELE gas模型。

该模型考虑到操作数大小，为任意精度算术操作定义gas(详见iele-gas)。

其与EVM主要区别在于：

-  由于IELE寄存器任意精度，则需要对寄存器数量进行内存记账。类似于EVM的栈用于传递参数指令，

每一个合约调用栈帧有一定量的免费内存(目前是32KB)。用完之后，增加的内存消费则需要成本。

之后的每一条指令的成本以线性增加，但随着内存逐渐增长，成本呈曲线增长。

-  如果通过减少使用寄存器数量或内存单元来释放内存，则可重用到其他地方已付费的相同数量内存，

而无需额外成本。

-  在指令执行产生大量结果之前，如果预计结果会增加峰值内存，则根据对结果大小的估计，来支付内存开销。

如果指令执行完毕后实际使用的内存少于估计值，则未使用的花费不予以退还(额外的内存仍需付费)。

-  每一条指令都有gas花费的公式，其依操作数的多少而参数化。

这也跟任意精度的算术运算与操作数多少并不渐进呈常量关系的事实一致。

#  3.IELE相对于LLVM设计的差异

1.   类型系统

不同于LLVM支持整形、浮点型有限精度。

IELE支持任意精度，但目前只支持整形。足以描述EVM，未来支持类似LLVM的聚合类型如数组、结构体以及高级函数类型。

2.  SSA

IELE寄存器非SSA形式，即其可以多次分配而不需要phi节点。

其旨在支持智能合约的解释性语言。为减少程序的gas消耗，尽量少的使用寄存器。这亦即表明与LLVM  SSA的不同之处。

生成IELE的编译器仍然可以在内部使用SSA IELE便于优化程序，但在最终的IELE程序或者手写代码中不会强制转换为SSA来优化寄存器的使用。

3.  控制流

LLVM对BB块结构的约束，代码被组织成包含显式、静态化的后继／前驱最大BB块控制流图(CFG)。

IELE会弱化这个约束，维持静态label作为唯一允许的跳转地址，同时允许执行一个BB块到另一个BB的fall-through。

而LLVM是BB块的第一条指令只能通过跳转到达，而且每一个BB块最后一条指令只能是控制流指令。

弱化这个约束的目的是，减少IELE程序的代码体积。因为LLVM程序中的这些约束会增加额外的分支指令。

4.  位移

由于IELE是任意精度的有符号整型，因此不用shr/shl指令，而是采用带符号的位移量来表示位移。


[参考](https://github.com/runtimeverification/iele-semantics/blob/master/Design.md)

